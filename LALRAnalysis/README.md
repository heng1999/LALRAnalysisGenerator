# LALR-1-Analysis-Algorithms
完整的LALR(1)分析算法,从first follow集计算，闭包生成到向前看为符号传播,LALR(1)自动机生成,语法分析表生成一应俱全
inputexample1和inputexample2为两个示例文法，以这两个示例文法为输入可以完美运行通过，从中选择你想要使用的文法并确保存放他的文件名称为inputeaxmple1即可

输出结果全部保存在文件ouput.txt中 包括first、follow集、firstK集,followK集、产生式、终结符、非终结符、LALR(1)自动机状态和LALR(1)语法分析表
此外程序中内置了firstK、followK集生成算法,firstK为非终结符或文法符号串能够推导出的终结符号串前K个终结符号的集合的集合,followK为某一句型中跟在给定非终结符
符后面的前K个终结符号的集合的集合,main函数中变量k即为K值

注意，当产生式数量较多且终结符号不多于100个时可以以K=2计算firstK和followK,终结符号超过30个时最好不要以K>=3计算firstK和followK，否则堆区占用空间过大对于规模较小的文法，可以尝试较大的K值。K值可以在LALR(1)Analysis.cpp文件的main函数中自行指定,在尝试较大的K值时建议在vs2017的项目属性-链接器-系统中修改堆和堆栈保留空间的大小，否则可能会抛bad_alloc异常

注意，对于示例文法inputexample1，如果使用visual studio 2017集成开发环境且切换至release模式,程序可以顺利运行通过，当K==2时构造分析表完成相关计算耗时57ms，内存占用峰值 5M,当K==3时耗时1587ms，内存占用峰值71M，当K==4时耗时约6分钟，内存占用峰值1.6GB,这是release模式下的运行结果,如果切换至debug模式，
K==2时耗时4030ms,内存占用峰值16MB,K==3时耗时136s,内存占用峰值229MB,K==4时时间太长，没有等待程序运行完毕。K==4时将结果数据输出至文件花费的时间比程序运算本身还长得多，最后的结果文件大小达到了160MB。
关于firstK算法的时间复杂度，如果产生式平均长度为L，文法终结符号数目为N，产生式数目为M，那么时间复杂度大约为O(U*M*N^(K*L)),这里U为迭代轮次，这里复杂度为指数级，所以K不能太大

本程序在windows系统下使用visual studio 2017IDE+MSVC编译器调试通过，不能保证对linux+gcc环境或clang编译器的兼容性

千万注意，自定义文法中绝对不能包含无用非终结符和无用产生式，否则程序必然崩溃

2019.1.28更新
在首次提交代码前修正了严重的内存泄漏错误,并修复了一个小bug
